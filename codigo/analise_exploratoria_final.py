# -*- coding: utf-8 -*-
"""analise_exploratoria_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1meAXrT3kgKSRy-K_b28mVf0gkLYywc40

#<center>**Trabalho final: Análise Exploratória de Dados**</center>

Grupo: Bianca Muniz, Meyrele Torres e Ricardo Grinbaum

## **Sobre a base escolhida**
A base de dados escolhida é a de **microdados dos atletas e delegações presentes nas edições dos Jogos Olímpicos a partir de 1896**. Ela foi obtida no site do projeto [Base dos Dados](https://basedosdados.org/dataset/5b6db46a-4203-41ba-8c69-36b8653f5241), originalmente encontrada no [Kaggle](https://www.kaggle.com/heesoo37/olympic-history-data-a-thorough-analysis).

## **Análise exploratória univariada**
Variável escolhida: `idade`
"""

# Importando as bibliotecas
import pandas as pd
import csv

# Carregando a base de dados
df = pd.read_csv(r'microdados.csv', sep=';')
print(df.describe())

"""Note que a base a base tem dados tem aproximadamente 270 mil observações, mas este valor não é compatível com o número de registros de `altura`, de `peso` e de `idade`. Logo, isso mostra a presença de missing data.

Olhando a base, podemos ver que há nomes que se repetem na coluna nome_atleta, pois um mesmo atleta pode participar de diferentes modalidades de um mesmo esporte.

Para prosseguirmos com a análise da idade, limpamos a base no Excel com a finalidade de ter um registro por atleta em cada edição dos jogos, excluindo dessa maneira as colunas medalha e evento. Em seguida, removemos os valores duplicados. Salvamos o novo conjunto de dados com o nome microdados_limpo.csv, este com 189765 registros únicos.

Para a análise bivariada de medalhistas de ouro e idade, retiramos os valores duplicados no excel e salvamos a base como microdados_medalhas.csv
"""

df.describe()

df

dados_limpo = pd.read_csv(r'microdados_limpo.csv', sep=';')
dados_medalhas = pd.read_csv(r'microdados_medalhas.csv', sep=';')

dados_limpo.select_dtypes(include=['number']) #incluindo um NaN nos dados ausentes
dados_medalhas.select_dtypes(include=['number'])#incluindo um NaN nos dados ausentes

# Análise descritiva da variável idade
dados_limpo['idade'].describe()

"""## **Análise exploratória bivariada**

### **Idade X sexo**
"""

# Estatísticas para o sexo feminino
feminino = dados_limpo["idade"].loc[dados_limpo['sexo'] == 'F']
feminino.describe()

# Estatísticas para o sexo masculino
masculino = dados_limpo["idade"].loc[dados_limpo['sexo'] == 'M']
masculino.describe()

# criando a tabela "est_idade_sexo", a partir de uma tabela dinâmica, comparando os resultados para os dois sexos
unused_columns = dados_limpo.columns.difference(set(['sexo']).union(set([])).union(set({'idade'})))
tmp_df = dados_limpo.drop(unused_columns, axis=1)
tab_dinamica_b = tmp_df.pivot_table(
    index=['sexo'],
    values=['idade'],
  aggfunc={'idade': ['mean', 'median', 'min', 'max', 'count']}) #media, mediana, valor mínimo e máximo para cada sexo
est_idade_sexo = tab_dinamica_b.reset_index()

est_idade_sexo

"""### Moda"""

# criando a tabela "contagem_sexo", a partir de uma tabela dinâmica
unused_columns = dados_limpo.columns.difference(set(['idade']).union(set(['sexo'])).union(set({'sexo'})))
tmp_df = dados_limpo.drop(unused_columns, axis=1)
tab_dinamica_a = tmp_df.pivot_table(
    index=['idade'],
    columns=['sexo'],
    values=['sexo'],
    aggfunc={'sexo': ['count']})  #### contar a quantidade de registros para cada sexo
contagem_sexo = tab_dinamica_a.reset_index()

print(contagem_sexo)

# Qual a idade mais frequente entre competidores do sexo feminino nos jogos olímpicos?
moda_f = contagem_sexo.sort_values(by=('sexo', 'count', 'F'), ascending=False, na_position='last') #coloca os valores de count_f em ordem descendente. O primeiro valor em f é a moda
print(moda_f) #o primeiro valor é o valor mais frequente

# Qual a idade mais frequente entre competidores do sexo masculina nos jogos olímpicos?
moda_m = contagem_sexo.sort_values(by=('sexo', 'count', 'M'), ascending=False, na_position='last')#coloca os valores de count_m em ordem descendente. O primeiro valor em m é a moda
print(moda_m) #o primeiro valor é o valor mais frequente

"""### **Idade X Medalha de ouro**"""

ouro = dados_medalhas.loc[dados_medalhas['medalha'] == 'Gold']
ouro.describe()

"""### **Gráfico: Frequência de idade**"""

# Import plotly and create a figure
import plotly.graph_objects as go
fig = go.Figure()


# Add the histogram traces to the figure
for column_header in ['idade']:
    fig.add_trace(go.Histogram(x=dados_limpo[column_header], name=column_header))

# Update the layout
# See Plotly documentation for customizations: https://plotly.com/python/reference/histogram/
fig.update_layout(
	xaxis_title='idade',
    title='idade frequencies',
    barmode='group'
)

"""### **Filtrando por Atletismo**"""

microdados_atletismo = dados_limpo[dados_limpo['esporte'].str.contains('Athletics', na=False)]
microdados_atletismo

"""### **Participação feminina nos jogos**"""

unused_columns = df.columns.difference(set(['ano']).union(set(['sexo'])).union(set({'id_atleta'})))
tmp_df = df.drop(unused_columns, axis=1)
pivot_table = tmp_df.pivot_table(
    index=['ano'],
    columns=['sexo'],
    values=['id_atleta'],
    aggfunc={'id_atleta': ['count']}
)


# Reset the column name and the indexes
df_f = pivot_table.reset_index()

df_f